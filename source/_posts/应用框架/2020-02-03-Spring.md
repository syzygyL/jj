---
title: Spring
tags:
  - note
comments: false
categories:
  - 应用框架
date: 2020-02-03 20:09:09
description:
top:
---

## Spring

Spring 是一个非侵入式的轻量级容器框架，它可以帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的 JDBC 访问实现，提供与第三方数据访问框架集成（如 Hibernate、JPA），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 Web 层框架 Spring MVC、而且还能非常简单的与第三方 web 框架集成，相当于**胶水**的作用

{%note info%}
框架是一组程序的集合，包含了一系列的最佳实践，作用是解决某个领域的问题，框架提供了骨架（通用代码），而程序设计者只需要提供血肉（业务逻辑代码）就行了。
{%endnote%}

### Spring 做了什么?

a.传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会造成程序的高度耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；此时而如果引入 Spring ，则由 Spring 这个第三者来集中化管理配置并提供这些资源，也降低了程序之间的耦合。

b.将日志记录、性能监测、权限控制、事务处理、异常处理等等系统层面的代码从业务逻辑代码中分离，从而对业务逻辑的各个部分进行隔离，提高了系统层代码的重用性，也同时降低了程序之间的耦合，提高了开发效率。AOP 其实是一种正交化编程设计思想，假设把应用程序想成一个立体结构的话，OOP 思想就是将利刃是纵向水平切入系统，把系统划分为很多个模块（如：用户模块，文章模块等等），而 AOP 思想的利刃是横向垂直切入系统，提取各个模块可能都要重复操作的部分（如：权限检查，日志记录，事务控制等等）

### IoC 

**什么是 IoC?**

控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低程序之间的耦合度(松耦合)，当 Spring 应用了 IoC ，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖的目标对象。IoC 与 JNDI 相反 —— JNDI 不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它

IoC 主要实现形式有两种:
主要是前两者：**依赖注入(Dependency Injection)**/控制反转或者是依赖查找(Dependency Lookup)而不是依赖倒置(Dependence Inversion Principle)

Spring 提供了好几种的方式来给属性赋值

1) 通过`构造函数`
2) 通过`setter`
3) 通过`p 名称空间`
4) 通过`自动装配`
5) 通过`注解`

**什么是 Bean?**

Spring Bean是被实例的，组装的及被 Spring 容器管理的 Java 对象，Spring 容器会自动完成 @bean 对象的实例化。创建应用对象之间的协作关系的行为称为：装配(wiring)，这就是依赖注入的本质

#### spring 中容器

常见实现类:
FileSystemXmlApplicationContext: 独立的 XML 应用程序上下文，从文件系统或 URL 获取上下文定义文件
ClassPathXmlApplicationContext: 独立的 XML 应用程序上下文，从类路径获取上下文定义文件
AnnotationConfigApplicationContext: 独立的注解应用程序上下文，接受组件类作为输入

![UML 类图](https://s2.ax1x.com/2020/02/06/160ofe.png)

BeanFactory 和 ApplicationContext 的区别：

1、创建 Bean 的时间点

ApplicationContext-----读取完配置文件，立即加载 Bean (适用单例) 
BeanFactory------------读取完配置文件，延迟加载 Bean (适用多例) 


在 Spring 中总体来看可以通过三种方式来配置对象:

a.使用 XML 文件配置
b.使用注解来配置
c.使用 JavaConfig 类来配置

#### spring 管理 Bean 

**xml 约束**

```xml
<?xml version="1.0" encoding="utf-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean>...</bean> 
</beans>
```

**创建Bean的三种方法**

使用默认构造器(一步)创建：某个类的默认构造器自动创建
使用普通工厂(两步)创建：某个类中的方法创建对象，并存入 spring 容器
使用静态工厂(一步)创建：某个类中的静态方法创建对象，并存入 spring 容器

**Bean 的五大作用域**：通过 bean 标签的 scope 属性指定

singleton：单例的（默认）
prototype：多例的
request：作用于 web 的请求
session：作用于 web 的会话
global-session：作用于集群环境下 web 的会话（全局会话），所有子服务器共享此 Bean

**Bean 的生命周期**

//TODO

#### 注解

使用注解时，需要更换 xml 约束为以下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="指定注解扫描的包"></context:component-scan>

    <bean>...</bean>
</beans>
```

**常见注解**

a.用于定义：

Component
  ├─ Controller
  ├─ Service
  ├─ Repository

b.用于注入：

以下三个注解只能注入其他 bean 类型的数据，而基本类型和 string 类型不能使用

Autowired 按类型自动注入
Qualifier 按名称自动注入（使用在类成员时，需要搭配 Autowired 注解一起使用）
Resource 

Value 注解可用于注入基本类型和 String 类型的数据(SpEL)

Value

c.用于改变生命周期：

Scope
  ├─ PostConstruct：指定初始化时执行的方法
  ├─ PreDestroy：指定销毁时执行的方法

d.新注解：（可完全脱离 xml 配置）

Configuration: 指定为配置类，获取配置时需要使用 AnnotationApplicationContext
Componentscan: 指定需要扫描的包
Bean: 用于将当前方法返回值作为 Bean 存入容器,若方法存在参数，则按照**Autowired 注解的自动注入的方式**来查找到参数
Import: 用于指定导入的**子配置类组件**的字节码
PropertySources/PropertySource: 用于指定`.properties`文件位置

e.集成 junit

1.导入 spring 整合 junit 的坐标
2.使用 junit 的 Runwith 注解指定新运行器替换原有的运行器
3.使用 spring 的 ContexConfiguration 注解指定 spring 配置文件的位置
4.使用 spring 的 Autowired 注解注入测试类中的成员

#### 依赖注入 Dependency Injection

通常用于不常变化的数据注入

构造函数注入: constructor-arg 标签（name 属性指定参数名，value 属性指定参数值，ref 属性指定参数引用的其他 Bean 的 id），常用于注入到第三方 jar 包中的类

Setter 注入：property 标签（name 属性指定参数名，value 属性指定参数值，ref 属性指定参数引用的其他 Bean 的 id）

对于使用 Spring 框架的开发人员来说，我们主要做的主要有两件事情：①开发 Bean;②配置 Bean;而 Spring 帮我们做的就是根据配置文件来创建Bean 实例，并调用 Bean 实例的方法来完成“依赖注入”，可以把 Spring 容器理解成一个大型工厂，Bean 就是该工厂的产品，工厂( Spirng 容器)里能生产出来什么样的产品(Bean)，完全取决于我们在配置文件中的配置。其实就是根据配置文件产生对象,而不需要人为的手动去创造对象,降低了耦合

用处不同：传统 javabean 更多地作为值传递参数，而spring中的bean用处几乎无处不在，任何组件都可以被称为bean
写法不同：传统 javabean 作为值对象，要求每个属性都提供getter和setter方法；但spring中的bean只需为接受设值注入的属性提供setter方法

### AOP 

**什么是 AOP?**

AOP 面向切面编程是 OOP 的延续，是一个概念，一个规范，面向切面编程则是希望能够将通用需求功能从不相关的类当中分离出来，能够使得很多类共享一个行为，一旦发生变化，不必修改很多类，而只需要修改这个行为即可。

Spring 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持

底层实现原理就是**动态代理**，通过代理控制对象的访问，实现方法的增强。

**Maven引入AOP**

```xml
<dependency>
  <groupId>org.aspectj</groupId>
  <artifactId>aspectjweaver</artifactId>
  <versio>1.8.7</versio>
</dependency>

```

#### JDK 动态代理（接口）

#### CGLIB 动态代理（子类）

#### AOP 相关术语

**Joinpoint(连接点)**: 被拦截到的点，Spring 只支持方法类型的连接点,具体体现形式就是**Service 层接口中的所有方法**,它连接我们的业务和增强的方法
**Pointcut(切入点)**: 指我们要对哪些 Joinpoint 拦截定义,具体体现形式就是 **Service 层接口中被动态代理增强的方法**
**Advice(通知/增强)**: 指拦截到 Joinpoint 后做的事情,通知类型:前置通知/后置通知/异常通知/最终通知/环绕通知(环绕通知是spring 提供的一种可以在代码中手动控制增强方法何时执行的方式)
**Introduction(引介)**: 是一种特殊的通知,在不修改类代码前提下,可在运行期为类动态地添加一些 Method/Field
**Target(目标对象)**: 代理的目标对象(被代理的类)
**Weaving(织入)**: 将增强代码应用到目标对象来创建新的代理对象的过程, Spring 采用动态代理织入,AspectJ 采用编译期织入和类装载织入
**Proxy(代理对象)**: 一个类被 AOP 织入增强后的产物(代理类)
**Aspect(切面)**: 是切入点和通知(引介)的结合

#### Spring AOP 干了啥？

Spring 框架监控切入点方法的执行,一旦监控到切入点方法被执行,将使用代理机制,动态创建目标对象的代理对象,根据通知类别,在代理对象的对应通知位置,将通知对应功能织入,完成完整代码的逻辑运行


#### 切入点表达式

// TODO

### SpEL

它的语法类似于传统 EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于 Spring产品的需求而设计他可以非常方便地同 Spring lOC进行交互

### 事务管理

#### 声明式事务

**声明式事务**以方法为单位，进行事务控制；抛出异常，事务回滚，最小的执行单位为方法。决定执行成败是通过是否抛出异常来判断的，抛出异常即执行失败，这里所说的声明，就是指在配置文件中声明。用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。

**好处**
非侵入式：事务管理不侵入开发的组件
插拔方便：不需要事务管理的时候，直接移除配置即可

PlatformTransactionManager 此接口是 Spring 的事务管理器，它里面提供了我们常用的操作事务的方法

**真正管理事务的对象**

`org.springframework.jdbc.datasource.DataSourceTransactionManager`事务管理器，使用 Spring JDBC 或 iBatis 进行持久化数据时使用

**事务的定义信息对象**

`TransactionDefinition`维护的 Spring 中的事务属性有以下五个

##### 传播行为 propagation

REQUIRED:   需要事务,外部存在事务融入当前事务,外部没有事务,开启新的事务
SUPPORTS:   支持事务,外部存在事务融入当前事务,外部没有事务,不开启新的事务
REQUIRES_NEW: 每次开启新的事务,如果外部存在事务外部事务挂起,开启新的事务运行,运行结束后回复外部事务
NOT_SUPPORTED: 不支持事务,如果外部存在事务外部事务挂起,已非事务方式运行.
NEVER:         不支持事务,存在事务报错
MANDATORY:     强制事务没有事务报错
NESTED:        嵌套事务,数据库不支持

##### 隔离级别 isolation 

DEFAULT: 采用数据库默认隔离级别
READ_UNCOMMITTED: 读未提交 
READ_COMMITTED: 读提交 用来避免脏读现象出现的   oracle 默认隔离级别
REPEATABLE_READ: 可重复读主要是用来避免不可重复读现象出现的 (在一次事务中一方更新,导致两次查询结果不一致这种情况叫不可重复读)  mysql 默认隔离级别
SERIALIZABLE   : 序列化读 用来避免幻影读现象出现          (在一次事务中一方插入,导致两次查询结果不一致这种情况叫幻读)

##### 读写性 readonly 

只读事务内，不能增加、修改、删除内容，否则报Cannot execute statement in a READ ONLY transaction。
只读事务内，只能读取到执行时间点前的内容，期间修改的内容不能读取到。
只读事务作为 ORM 框架优化执行的一个暗号，比如放弃加锁，或者flush never

关于只读事务：

**MySQL 在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现 Cannot execute statement in a READ ONLY transaction，注意 Oracle 不支持此配置**

网上的各种资料里众说纷纭：

“只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。
但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。
因此，“只读事务” 仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。

```xml
<!-- 一般配置 -->
<!-- 增删改 -->
<tx:method name="*" propagation="REQUIRED" read-only="false" isolation="SERIALIZABLE"/>
<!-- 查询 -->
<tx:method name="find*" propagation="REQUIRED" read-only="true" isolation="SERIALIZABLE"/>
```

##### 超时性 timeout 

timeout: -1 永不超时

##### 回滚性 rollback-for && no-rollback-for

rollback-for: 遇到什么异常类回滚
no-rollback-for: 遇到什么异常类不回滚

**以上两个属性都不设置时，表示遇到异常都回滚**

```xml
<tx:method name="save*" rollback-for="" no-rollback-for="" propagation="REQUIRES_NEW" read-only="true" isolation="SERIALIZABLE"/>
```

#### 编码式事务

TransactionTemplate 事务模板

// TODO

### Spring 主要模块

![Spring 主要模块](https://s2.ax1x.com/2020/02/10/15z5d0.png)

**数据访问及集成**: 由 spring-jdbc、 spring-tX、 spring-orm、 spring-ms和 spring-oXm5个模块组成spring-jdbo模块是 Spring提供的JDBC抽象框架的主要实现模块，用于简化 Spring JDBC。主要是提供JDBC模板方式、关系数据库对象化方式、 SimpleJdbc方式、事务管理来简化JDBC编程，主要实现类是 JdbcTemplate、 SimpleJdbcTemplate以及NamedParameterJdbcTemplateo springⅸx模块是 Spring JDBC事务控制实现模块。使用 Spring框架，它对事务做了很好的封装。

**Web**: 由 spring-Web、 spring-Webmvc、 spring- websocket和 spring-Webflux4个模块组spring-web模块为 Spring提供了最基础Web支持，主要建立于核心容器之上，通过Servlet或者 Listeners来初始化|OC容器，也包含一些与Web相关的支持。spring- webm模块众所周知是一个的web- Servlet模块，实现了 Spring MVC（ model-vieW- Controller）的Web应用。spring-websocket模块主要是与Web前端的全双工通讯的协议。（资料缺乏，这是个人理解）spring-Webflux是一个新的非堵塞函数式 Reactive Web框架，可以用来建立异步的，非阻事件驱动的服务，并且扩展性非常好。增加了对国际化、事件传播，以及验证等的支持，此外还提供了许多企业服务及对模版框架集成的支持。

**AOP 和设备支撑**: 由 spring-aop、 spring-aspects 和 spring-Instrument 3 个模块组成。提供了 AOP（拦截器）机制，提供了符合 AOP Alliance 规范的面向切面的编程实现，让你可以定义，例如方法拦截器（method-interceptors）和切入点（pointcuts），从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用 source-level 的元数据功能，还可以将各种行为信息合并到你的代码中。

**Core Container**: Core Container 模块整合了 Beans，Core，Context，SpEL，主要的功能是实现了反向控制 IOC（Inversion of Control）与依赖注入 DI（Dependency Injection）、Bean 配置以及加载，其中涉及到的有 Beans、BeanFactory、BeanDefinitions、ApplicationContext、Spring 的 EL 表达式等几个重要概念。

**Test**: spring-test 模块主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。
 