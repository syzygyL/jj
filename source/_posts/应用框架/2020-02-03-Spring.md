---
title: Spring
tags:
  - note
comments: false
categories:
  - 应用框架
date: 2020-02-03 20:09:09
description:
top:
---

## Spring

Spring 是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架

目的：解决企业应用开发的复杂性
功能：使用基本的 JavaBean 代替 EJB ，并提供了更多的企业应用功能
范围：任何 Java 应用

### IoC 

**什么是 IoC?**

控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低程序之间的耦合度(松耦合)，当 Spring 应用了 IoC ，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖的目标对象。IoC 与 JNDI 相反 —— JNDI 不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它

IoC 主要形式有两种:
依赖注入 Dependency Injection
依赖查找 Dependency Lookup

**什么是 Bean?**

Spring Bean是被实例的，组装的及被 Spring 容器管理的 Java 对象，Spring 容器会自动完成 @bean 对象的实例化。创建应用对象之间的协作关系的行为称为：装配(wiring)，这就是依赖注入的本质

#### spring 中工厂的类结构图

常见实现类:
FileSystemXmlApplicationContext: 独立的 XML 应用程序上下文，从文件系统或 URL 获取上下文定义文件
ClassPathXmlApplicationContext: 独立的 XML 应用程序上下文，从类路径获取上下文定义文件
AnnotationConfigApplicationContext: 独立的注解应用程序上下文，接受组件类作为输入

![UML 类图](https://s2.ax1x.com/2020/02/06/160ofe.png)

BeanFactory 和 ApplicationContext 的区别：

1、创建 Bean 的时间点

ApplicationContext-----读取完配置文件，立即加载 Bean (适用单例) 
BeanFactory------------读取完配置文件，延迟加载 Bean (适用多例) 

#### spring 管理 Bean 

**xml 约束**

```xml
<?xml version="1.0" encoding="utf-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean>...</bean> 
</beans>
```

**创建Bean的三种方法**

使用默认构造器(一步)创建：某个类的默认构造器自动创建
使用普通工厂(两步)创建：某个类中的方法创建对象，并存入 spring 容器
使用静态工厂(一步)创建：某个类中的静态方法创建对象，并存入 spring 容器

**Bean 的五大作用域**：通过 bean 标签的 scope 属性指定

singleton：单例的（默认）
prototype：多例的
request：作用于 web 的请求
session：作用于 web 的会话
global-session：作用于集群环境下 web 的会话（全局会话），所有子服务器共享此 Bean

**Bean 的生命周期**

//TODO

#### 注解

使用注解时，需要更换 xml 约束为以下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="指定注解扫描的包"></context:component-scan>

    <bean>...</bean>
</beans>
```

**常见注解**

a.用于定义：

Component
  ├─ Controller
  ├─ Service
  ├─ Repository

b.用于注入：

以下三个注解只能注入其他 bean 类型的数据，而基本类型和 string 类型不能使用

Autowired 按类型自动注入
Qualifier 按名称自动注入（使用在类成员时，需要搭配 Autowired 注解一起使用）
Resource 

Value 注解可用于注入基本类型和 String 类型的数据(SpEL)

Value

c.用于改变生命周期：

Scope
  ├─ PostConstruct：指定初始化时执行的方法
  ├─ PreDestroy：指定销毁时执行的方法

d.新注解：（可完全脱离 xml 配置）

Configuration: 指定为配置类，获取配置时需要使用 AnnotationApplicationContext
Componentscan: 指定需要扫描的包
Bean: 用于将当前方法返回值作为 Bean 存入容器,若方法存在参数，则按照**Autowired 注解的自动注入的方式**来查找到参数
Import: 用于指定导入的**子配置类组件**的字节码
PropertySources/PropertySource: 用于指定`.properties`文件位置

e.集成 junit

1.导入 spring 整合 junit 的坐标
2.使用 junit 的 Runwith 注解指定新运行器替换原有的运行器
3.使用 spring 的 ContexConfiguration 注解指定 spring 配置文件的位置
4.使用 spring 的 Autowired 注解注入测试类中的成员

#### 依赖注入 Dependency Injection

通常用于不常变化的数据注入

构造函数注入: constructor-arg 标签（name 属性指定参数名，value 属性指定参数值，ref 属性指定参数引用的其他 Bean 的 id），常用于注入到第三方 jar 包中的类

Setter 注入：property 标签（name 属性指定参数名，value 属性指定参数值，ref 属性指定参数引用的其他 Bean 的 id）

对于使用 Spring 框架的开发人员来说，我们主要做的主要有两件事情：①开发 Bean;②配置 Bean;而 Spring 帮我们做的就是根据配置文件来创建Bean 实例，并调用 Bean 实例的方法来完成“依赖注入”，可以把 Spring 容器理解成一个大型工厂，Bean 就是该工厂的产品，工厂( Spirng 容器)里能生产出来什么样的产品(Bean)，完全取决于我们在配置文件中的配置。其实就是根据配置文件产生对象,而不需要人为的手动去创造对象,降低了耦合

用处不同：传统 javabean 更多地作为值传递参数，而spring中的bean用处几乎无处不在，任何组件都可以被称为bean
写法不同：传统 javabean 作为值对象，要求每个属性都提供getter和setter方法；但spring中的bean只需为接受设值注入的属性提供setter方法

### AOP 

**什么是 AOP?**

AOP 面向切面编程是 OOP 的延续，是一个概念，一个规范，面向切面编程则是希望能够将通用需求功能从不相关的类当中分离出来，能够使得很多类共享一个行为，一旦发生变化，不必修改很多类，而只需要修改这个行为即可。

Spring 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持


**Maven引入AOP**

```xml
<dependency>
  <groupId>org.aspectj</groupId>
  <artifactId>aspectjweaver</artifactId>
  <versio>1.8.7</versio>
</dependency>

```

#### AOP 相关术语

**Joinpoint(连接点)**: 被拦截到的点，Spring 只支持方法类型的连接点,具体体现形式就是**Service 层接口中的所有方法**,它连接我们的业务和增强的方法
**Pointcut(切入点)**: 指我们要对哪些 Joinpoint 拦截定义,具体体现形式就是 **Service 层接口中被动态代理增强的方法**
**Advice(通知/增强)**: 指拦截到 Joinpoint 后做的事情,通知类型:前置通知/后置通知/异常通知/最终通知/环绕通知(环绕通知是spring 提供的一种可以在代码中手动控制增强方法何时执行的方式)
**Introduction(引介)**: 是一种特殊的通知,在不修改类代码前提下,可在运行期为类动态地添加一些 Method/Field
**Target(目标对象)**: 代理的目标对象(被代理的类)
**Weaving(织入)**: 将增强代码应用到目标对象来创建新的代理对象的过程, Spring 采用动态代理织入,AspectJ 采用编译期织入和类装载织入
**Proxy(代理对象)**: 一个类被 AOP 织入增强后的产物(代理类)
**Aspect(切面)**: 是切入点和通知(引介)的结合

#### Spring AOP 干了啥？

Spring 框架监控切入点方法的执行,一旦监控到切入点方法被执行,将使用代理机制,动态创建目标对象的代理对象,根据通知类别,在代理对象的对应通知位置,将通知对应功能织入,完成完整代码的逻辑运行


#### 切入点表达式

// TODO

### 声明式事务

**声明式事务**以方法为单位，进行事务控制；抛出异常，事务回滚，最小的执行单位为方法。决定执行成败是通过是否抛出异常来判断的，抛出异常即执行失败，这里所说的声明，就是指在配置文件中声明。用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。

**好处**
非侵入式：事务管理不侵入开发的组件
插拔方便：不需要事务管理的时候，直接移除配置即可

PlatformTransactionManager 此接口是 Spring 的事务管理器，它里面提供了我们常用的操作事务的方法

**真正管理事务的对象**

`org.springframework.jdbc.datasource.DataSourceTransactionManager` 使用 Spring JDBC 或 iBatis 进行持久化数据时使用

**事务的定义信息对象**

`TransactionDefinition`维护的 Spring 中的事务属性有以下五个

#### 传播行为 propagation

REQUIRED:   需要事务,外部存在事务融入当前事务,外部没有事务,开启新的事务
SUPPORTS:   支持事务,外部存在事务融入当前事务,外部没有事务,不开启新的事务
REQUIRES_NEW: 每次开启新的事务,如果外部存在事务外部事务挂起,开启新的事务运行,运行结束后回复外部事务
NOT_SUPPORTED: 不支持事务,如果外部存在事务外部事务挂起,已非事务方式运行.
NEVER:         不支持事务,存在事务报错
MANDATORY:     强制事务没有事务报错
NESTED:        嵌套事务,数据库不支持

#### 隔离级别 isolation 

DEFAULT: 采用数据库默认隔离级别
READ_UNCOMMITTED: 读未提交 
READ_COMMITTED: 读提交 用来避免脏读现象出现的   oracle默认隔离级别
REPEATABLE_READ: 可重复读主要是用来避免不可重复读现象出现的 (在一次事务中一方更新,导致两次查询结果不一致这种情况叫不可重复读)  mysql默认隔离级别
SERIALIZABLE   : 序列化读 用来避免幻影读现象出现          (在一次事务中一方插入,导致两次查询结果不一致这种情况叫幻读)

#### 读写 readonly 

只读事务内，不能增加、修改、删除内容，否则报Cannot execute statement in a READ ONLY transaction。
只读事务内，只能读取到执行时间点前的内容，期间修改的内容不能读取到。
只读事务作为 ORM 框架优化执行的一个暗号，比如放弃加锁，或者flush never

关于只读事务：

**MySQL 在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现 Cannot execute statement in a READ ONLY transaction，注意 Oracle 不支持此配置**

网上的各种资料里众说纷纭：

“只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。
但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。
因此，“只读事务” 仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。

```xml
<!-- 一般配置 -->
<!-- 增删改 -->
<tx:method name="*" propagation="REQUIRED" read-only="false" isolation="SERIALIZABLE"/>
<!-- 查询 -->
<tx:method name="find*" propagation="REQUIRED" read-only="true" isolation="SERIALIZABLE"/>
```

#### 超时性 timeout 

timeout: -1 永不超时

#### 回滚属性 rollback-for && no-rollback-for

rollback-for: 遇到什么异常类回滚
no-rollback-for: 遇到什么异常类不回滚

**以上两个属性都不设置时，表示遇到异常都回滚**

```xml
<tx:method name="save*" rollback-for="" no-rollback-for="" propagation="REQUIRES_NEW" read-only="true" isolation="SERIALIZABLE"/>
```

### Spring 主要模块

Spring 框架由七个定义明确的模块组成

//TODO

