---
title: Dubbo
tags:
  - note
comments: false
categories:
  - 应用框架
date: 2020-02-10 18:58:47
description:
top:
---

## 引

学习 dubbo 之前我们有必要了解下分布式系统这个概念。
当一个互联网业务获得大众欢迎的时候，最显著碰到的技术问题，就是服务器非常繁忙。当每天有1000万个用户访问你的网站时，无论你使用什么样的服务器硬件，都不可能只用一台机器就承载的了。因此，在互联网程序员解决服务器端问题的时候，必须要考虑如何使用多台服务器，为同一种互联网应用提供服务，这就是所谓“分布式系统”的来源。

分布式的世界中涉及到大量的协议（raft、2pc、lease、quorum等）、大量的理论（FLP， CAP等）、大量的系统（GFS、MongoDB、MapReduce、Spark、RabbitMQ等）

负载均衡:这里就拿 IP 负载均衡来说吧，**IP负载均衡**是对外提供一个公共地址，请求过来时通过轮询、随机等，路由到不同 Server。目的是分摊访问压力。

## Dubbo

### Dubbo 作用

Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的**RPC 远程服务调用方案**，以及**SOA 服务治理方案**，协议和序列化框架都可以插拔是极其鲜明的特色。

在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。

**什么叫RPC**

Remote Procedure Call 远程过程调用，是分布式架构的核心，按响应方式分如下两种：

​	同步调用：客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作。

​	异步调用：客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。

- 是一种进程间的通信方式

- 它允许应用程序调用网络上的另一个应用程序中的方法

- 对于服务的消费者而言，无需了解远程调用的底层细节，是透明的

  需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。

  RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo、spring Cloud等。

**为什么要RPC**

RPC 是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据.

简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）。

* 同步调用：需等待结果
* 异步调用：无需等待结果

**核心部分**

1. 远程通讯
提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。

2. 集群容错
提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。

3. 自动发现
基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

### 系统架构演变

**随系统复杂度的增长，系统架构的变化和侧重点**

**单一应用架构**
  当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。
  此时，用于简化增删改查工作量的**数据访问框架(ORM)**是关键。

**垂直应用架构**
  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。
  此时，用于加速前端页面开发的**Web 框架(MVC)**是关键。

**分布式服务架构**
  当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。
  此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。

**流动计算架构**
  当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。
  此时，用于提高机器利用率的**资源调度和治理中心(SOA)**是关键。
  SOA的标志：服务粒度粗、数据库单一、ESB/SOAP

### Dubbo 分层

服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。

配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。

服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。

服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。

集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。

监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。

远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。

信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。

网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。

数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。

### Dubbo 适用场景

1.RPC 分布式服务

当网站变大后，不可避免的需要拆分应用进行服务化，以提高开发效率，调优性能，节省关键竞争资源等。

比如：为了适用不断变化的市场需求，以及多个垂直应用之间数据交互方便，我们把公共的业务抽取出来作为独立的模块，为其他的应用提供服务，系统逐渐依赖于抽象和rpc远程服务调用。

2.配置管理

当服务越来越多时，服务的URL地址信息就会爆炸式增长，配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。

3.服务依赖

当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。

4.服务扩容

接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？等等……

### Dubbo 架构分析

#### 角色

Provider：暴露服务的服务提供者

Container：服务运行的容器

Consumer：调用远程服务的消费者

Registry：服务注册和发现的注册中心

Minitor：统计服务调用次数和时间的监控中心

#### 调用过程

1、服务容器负责启动，加载，运行服务提供者
2、服务提供者在启动时，向注册中心注册自己提供的服务。
3、服务消费者在启动时，向注册中心订阅自己所需的服务。
4、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。


Dubbo提供了三大核心能力：**面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现**。

----

### Dubbo 入门

#### quickstart

//todo

#### 负载均衡

Dubbo 负载均衡是体现在服务层面的，内置了 4 种负载均衡策略:

RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的默认负载均衡策略。
RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。
LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。
ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。

### CAP

Consistency：数据一致性，这个很容易理解，就是没有脏数据。我们知道，在Mysql中有一致性的概念，比如参照完整性约束、事务等。但这里的C主要特指同1份数据的多个备份之间的一致性。

Availability：可用性有2重意思，一个是说稳定性，服务可用，不会挂；另外一个是性能，也就是要快，如果延迟很高，经常超时，那和挂了也就区别不大了。

Partition tolerance(分区容错性)：分区，其实指网络分区。当你把数据从1个物理设备，分到多个物理设备之后，设备之间必然是通过网络进行通信。这就会遇到网络分区，也就是典型的“2将军问题“，网络超时时间不定。学术上有个词，叫“异步通信环境“。

以前说CAP理论，说对于一个分布式系统，上面3个，只能同时满足2个。但这个其实不准确，P其实一定存在，是你避免不了的。能做的，其实主要是在C和A之间权衡。

比如拿Mysql来说，它的C最强，A次之，P最弱。如果你为了A，给数据做冗余，比如重写轻读，那C就很难保证；为了P，给数据做分库分表，那就做不了事务；

比如Nosql，P最强，可以很好的做数据拆分，但C就不够，做不了事务；

比如微博系统，对C的要求降低，就可以加很多缓存，提高A；数据分片，提高P；

而支付，交易转帐，对C的要求很高，就不能简单的用Cache来提高性能

最终一致性

前面提到，在分布式系统中，因为数据的分拆，服务的分拆，强一致性就很难保证。这个时候，用的最多的就是“最终一致性“。

强一致性，弱一致性，最终一致性，是一致性的几个不同的等级。在传统的关系型数据库中，通过事务来保证强一致性。

但在分布式系统中，通常都会把强一致性折中成最终一致性，从而变相的解决分布式事务问题。最终一致性的实现，通常都需要一个高可靠的消息队列。

---