---
title: SE01-OO编程思想
tags:
  - note
comments: false
categories:
  - 基础学习
  - SE
date: 2019-11-26 8:01:39
description:
top:
---

## OO编程思想 

{% note info %}
万物皆对象。以对象为中心，以消息为驱动。
{% endnote %}

**类（class）** ：类是一个模板，它描述一类对象的行为和属性(状态)，对应程序中的方法和数据。
**实例化（instance）**：由类转换为（构造）对象的过程
**对象（object）**：每个对象都是某个类的一个实例，它具有**行为、状态、和标识**三个主要特性
**实例域（filed）**：对象中的数据
**方法（method）**：方法签名（方法名、参数类型）、返回值、方法体
**构造器（constructor）**：随着 `new` 关键字的出现而调用，用于初始化成员属性，实例化一个类
**重载（overload）**：发生在同一个类中，编译器检查（重载解析）
在只有返回值不同或者访问修饰符不同的情况下无法构成重载

{% note primary %}必要条件：**方法名相同，同一个类中**{% endnote %}

{%note default%}

次要条件：（必须满足其一）
  - 参数类型不同
  - 参数个数不同
  - 参数顺序不同

{%endnote%}

**重写（override）**：发生在子父类中，使用`@Override`检查
父类某个方法访问修饰符为 `private` ，则子类无法重写此方法


{% note primary %}必要条件：**方法名、参数类型和个数相同，发生在子父类中**{% endnote %}

{%note default%}

次要条件：（可选）
  - 访问修饰符范围大于等于父类 
  - 返回值类型小于等于父类 
  - 抛出的异常范围小于等于父类 

{%endnote%}

{% note info %}

在 Java1.4 及以前，子类方法如果要**重写**父类中的某个方法，必须具有完全相同的方法签名，包括返回值也必须完全一样。
Java 5.0 中新增了协变返回类型，它允许子类中重写父类方法的返回类型为`父类的返回类型的某个子类类型`

{% endnote %}

**封装**：java 中通过控制类成员的访问权限，隐藏其对象的属性和实现细节，仅向外提供 public 的 getXXX() 和 setXXX()，形成`"类"`的过程
**继承**：利用继承(is-a)技术，可以基于一个已存在的类来构造一个新类，在其之上进行扩展
好处：
  * 提高**代码的复用性**（减少代码冗余，相同代码重复利用）
  * 使类与类之间产生了联系
  * 子类继承父类，就可以直接得到父类的成员变量和方法

注意：并不是父类的所有内容都可以给子类继承的：
**子类不能继承父类的构造器，因为子类有自己的构造器**
**子类可以继承父类的 protected 成员并且可以直接访问**
**子类可以继承父类的 private 成员**
* private 成员变量：无法直接访问，可以通过 getXXX() / setXXX() 访问父类的 private 成员变量。
* private 成员方法：无法访问、无法调用。（可间接调用）


判断什么时候使用继承的先决条件：**先看是否需要子类转型为父类**，如果必须向上转型，则继承是必须的，否则可以使用组合代替继承。如果多个类中有相同的属性和行为，并且这多个类向上抽象可以看出是同一类事物，那么就可以使用继承来提高代码的复用性

继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障

**组合**：表示两个对象之间是整体和部分的*强关联关系*，部分与整体的生命周期相同(例如：人与大脑的关系)

常见实现方式：A类的构造方法里创建B类的对象，也就是说，当A类的一个对象产生时，B类的对象随之产生，当A类的这个对象消亡时，它所包含的B类的对象也随之消亡

**聚合**：表示两个对象之间是整体和部分的*弱关联关系*，部分的生命周期可以超越整体(例如：计算机与外设的关系)

常见实现方式：A类的对象在创建时不会立即创建B类的对象，而是等待一个外界的对象传给它，传给它的这个对象不是A类创建的

{% note info %}

is-a: 这种事物(绵羊)是那种事物(羊)中的一个种类。Java 中体现形式为子父类之间的继承关系
    
has-a:这种事物(羊毛)隶属于那种事物(绵羊)，是它的一个部分、部件。Java 中体现形式一个类中包含了其他类的组合（聚合）关系

{% endnote %} 

**抽象类**：抽象类体现了程序设计的模板思想，我们将包含一个、零个或多个抽象方法的类称为抽象类。抽象类除了不能被实例化以外，其他功能于普通类一样（**注意：抽象类拥有构造器**）

{%note info%}

抽象方法：当父类方法被子类重写时，方法体的存在没有意义，可以将方法改为抽象方法。此方法仅有声明没有方法体，以分号结尾。
a.任何子类都必须重写所有的父类抽象方法，否则它被声明为抽象类
b.抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类
c.构造器， static 修饰的方法不能声明为抽象方法

{%endnote%}

**接口**：接口不能被实例化，它是`抽象类`更具抽象化的产物，接口描述的是某类事物的功能扩展，它是一种数据类型，主要用于明确类中的方法名、参数列表、返回类型

接口中的任何域都自动是 public static final 修饰的 
  ```java
    public/default interface 接口名{
      //常量（jdk7+） 默认用 public static final 修饰 可以省略
      //抽象方法（jdk7+） 默认用 public abstract 修饰 可以省略
      //默认方法（jdk8+） 使用 default 修饰 不可以省略
      //静态方法（jdk8+） 使用 static 修饰 不可以省略  默认权限修饰符为 public 可以省略
      //私有方法（jdk9） 使用 private 修饰 不可以省略
    }
  ```

* 单继承：一个类只能直接继承一个父类
* 多继承：一个接口可以继承多个接口
* 多实现：一个类实现多个接口
  

接口、抽象类区别：
      
0.接口的实现类不能访问接口的 static 方法，而子类可以访问父类的static 方法

1.接口的方法默认是 public ，Java 8 之前的接口中不能有默认方法，而抽象类可以有非抽象的方法。

2.接口中除了 static 、 final 变量，不能有其他变量，而抽象类中则不一定。

3.一个类可以实现多个接口，但只能继承一个抽象类。接口自己本身可以通过 extends 关键字继承多个接口。

4.接口方法默认修饰符是 public，抽象方法可以有 public、 protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。

5.从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。


**多态**：构成多态三个必要条件：**继承/实现**、**方法重写**、**父类引用指向子类对象**

利：提高代码复用性，降低冗余，提高程序扩展性，降低耦合
弊：无法通过父类引用操作子类特有成员 

多态下同名成员访问特点：
* 访问成员变量时：访问的是父类的成员变量，不能访问子类特有成员
* 访问成员方法时：访问的是子类的成员方法，可以通过 super 关键字

常见应用场景：
* 变量多态：子类对象赋值给父类引用类型
* 形参多态：方法的形参类型为父类类型，那么该方法可以接收该父类对象以及该父类的所有子类对象
* 返回值多态：方法的返回值类型为父类类型，那么就可以返回该父类对象以及该父类的所有子类对象

{%note info%}

向上转型：由子类（导出类）转型为父类（基类） `较专用` -----> `较通用` 
向下转型：可以解决多态的弊端：无法通过父类引用操作子类特有成员
**每次向下转型前必须已经是父类类型**，通常搭配 `instanceof`避免类型转换异常--ClassCastException
 
{%endnote%}

**静态绑定**：由编译器在编译阶段确定在程序运行时，到底调用的是子类还是父类中的方法的过程
静态绑定的方法包括：构造器、 static 方法、final 方法（ private 方法隐式属于 final 方法）、 super 调用的方法(包括父类构造器和父类成yishi员方法)

**动态绑定**：编译器在编译阶段不能确定，只能通过在运行时根据实际类型而不是引用类型来调用相关方法，即取决于我们新创建了什么样的对象，除了上述静态绑定的 4 种情况外，Java 中的由对象调用的方法都采用动态绑定

**内部类**：定义在类中方法外的类，比如：A 类的定义放在 B 类的定义内部，A 类就是一个内部类
* 内部类中拥有外部类所有元素（包括 private 成员 ）的访问权（不用实例化）
* 外部类可以通过在非静态域中实例化内部类，使用内部类对象来访问内部类成员
* 当内部类拥有 static 成员时，此内部类必须为 static 类
* 在其他类中创建内部类对象的格式：外部类名.内部类名 对象名 = new 外部类名().new 内部类名()；

```java
// 外部类 Out
public class Out {
    public int a;
    protected int b;
    private int c;
    static int s = 40;

    public Out() {
    }

    public Out(int a， int b， int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    // 内部类 In
    class In {
        Out o = new Out(10， 20， 30);

        public void test1() {
            printf("通过内部类访问外部类的 public 成员:%d\n"， o.a = 100);
            printf("通过内部类访问外部类的 protected 成员:%d\n"， o.b = 200);
            printf("通过内部类访问外部类的 private 成员:%d\n"， o.c = 300);
            printf("通过内部类访问外部类的 static 成员:%d\n"， o.s = 400);
        }
    }

    public static void main(String[] args) {
        //创建内部类对象
        Out.In outIn = new Out().new In();
        printf("内部类：%s\n"， outIn);
        outIn.test1();
    }
    /** output：
     * 内部类：Out$In@65b3120a
     * 通过内部类访问外部类的 public 成员:100
     * 通过内部类访问外部类的 protected 成员:200
     * 通过内部类访问外部类的 private 成员:300
     * 通过内部类访问外部类的 static 成员:400
     */
}
```
* **匿名内部类**：本质是**一个带有具体实现的** 父类(父接口)的 **匿名** 继承(实现)类对象
  * `继承了某个类的匿名子类的匿名对象`
  * `实现了某接口的匿名实现类的匿名对象`

* **静态内部类**


**常见关键字**

* final 修饰场景：`数据、方法、类`

  * `final 数据`：该变量的引用不可改变
    * 常用于修饰基本类型，修饰引用类型时，final 使其引用一旦被初始化，就无法改为引用其他对象，但其对象自身是可以被修改的
    * Java 允许 final 以声明的方式修饰参数，意味着不能在方法里修改引用所指向的对象(可以读参数，不可以修改参数)
  * `final 方法`：该方法不可被重写
    * 用于使方法行为保持不变，禁止覆盖（还有一个作用相当于c中的内联）
    * 类中的所有 private 方法隐式的指定为 final
  * `final 类`：该类不可被继承
    * 用于禁止继承该类，此类中所有方法都隐式指定为 final

  * final、finally、finalize
  1.final— 修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。
  2.finally —异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。
  3.finalize —方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

* static 修饰场景：`数据/方法、代码块、静态导入、内部类`

  * `static 数据/方法`：static 修饰的数据和方法属于类，不属于类的某个对象，通过类名调用，常用于创建工具方法。调用格式：类名.静态变量名 / 类名.静态方法名()
  * `static 代码块`：静态代码块定义在`类中方法外`， 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)，执行次数只有一次，不随 new 的对象增加而增加，常用于加载配置信息， 或用来一次性地对静态成员变量进行赋值。。
  * `static 静态导入`：通过在 import 关键字后加 static，使调用某个类时无需书写类名即可调用该类中的静态资源
  * `static 内部类`：
    * 成员内部类
    * 匿名内部类

{%note danger%}
static final常量

1.常量必须声明同时初始化。
2.由类名点来访问、不能被改变。
3.建议：所有字母都大写。
4.编译器在编译时被自动替换为具体的值，效率高。
{%endnote%}

* this 用于表示`引用类的当前实例本身`

  * this.成员变量：用于区分成员变量与局部变量
  * this.成员方法：不常用
  * this()：调用该类的其他构造器

* super 用于表示`该类的父类引用`
  * 从子类中访问父类的变量和方法
  * 调用父类构造器（须在子类构造器首行）

注意：
  * this、super 都不能在 static 方法内使用
  * 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量
  ```java
  public class Tk1 {
    @Test
    public void test(){
        new A(1) {}.method(10);
    }
  }
  class A {
    private int num;

    public A(int num) {
        this.num = num;
    }

    public void method(int num) {
        println(this.num); // 1
        println(num);      // 10
    }
  }
  ```

**访问权限修饰符**

* 公有访问修饰符-------`public `：**所有类可见**，使用对象：类、接口、变量、方法
* 受保护访问修饰符---`protected`：**同一包内的类和所有子类可见**。使用对象：变量、方法
* 默认访问修饰符-------`default`：**同一包内可见**，不使用任何修饰符。使用对象：类、接口、变量、方法
* 私有访问修饰符-------`private`：**同一类内可见**，使用对象：变量、方法

注意：
  a. private 和 protected 不能修饰外部类，可以用来修饰内部类
  b.父类 protected 成员是包内可见的，并且对子类可见
  c.若子类与父类非同包，那么在子类中，可以通过创建子类实例来访问父类 protected  方法，而不能通过创建父类实例来访问父类的 protected 方法
  d.类的访问控制只能是 public 和 defult，public 修饰的可以被任何一个类调用，默认访问控制的类只能被同一个包中的类使用

**Java中的深拷贝(深复制)和浅拷贝(浅复制)**

深拷贝(深复制)和浅拷贝(浅复制)是两个比较通用的概念，尤其在C++语言中，若不弄懂，则会在delete的时候出问题，但是我们在这幸好用的是Java。虽然java自动管理对象的回收，但对于深拷贝(深复制)和浅拷贝(浅复制)，我们还是要给予足够的重视，因为有时这两个概念往往会给我们带来不小的困惑。

浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。

## 六大原则

### 单一职责原则 SRP

Single Responsibility Principle: **对一个类而言，应该只专注于做一件事和仅有一个引起它变化的原因**。通俗的讲，某个类应该只负责单一功能，当有两个变化会要求修改这个类，那么就要考虑拆分这个类，因为当后来者 b 变化要求修改类时，可能会影响到 a 变化修改后此类的正常运作

### 里氏替换原则 LSP
Liskov Substitution Principle: **里氏替换原则依赖于继承、多态**。只要父类能出现的地方子类就可以出现（因为继承），而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类。但是反过来不行，有子类出现的地方，父类未必适应（子类有的方法父类未必有）

### 依赖倒置原则 DIP

Dependence Inversion Principle: **依赖倒置原则依赖于抽象，而不依赖具体实现**。模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口和抽象类产生的

《敏捷软件开发》：

{%note success %}

依赖倒置原则
a.高层模块不应该依赖于底层模块，二者都应该依赖于抽象。
b.抽象不应该依赖于细节，细节应该依赖于抽象。

{%endnote%}

### 接口隔离原则 ISP

Interface Segregation Principles: **客户端不应该依赖它不需要的接口**。通俗的讲，在设计类时，我们需要将各种接口隔离，使用多个专一功能的接口比使用一个的总接口总要好。过于臃肿的接口是对接口的污染，不应该强迫客户依赖于它们不用的方法。

### 迪米特原则 LOD

Law of Demeter: 又称最少知道原则(Demeter Principle)，它指出**类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大**。

### 开放封闭原则 OCP

Open Close Principle: **程序中的对象（类、模块、函数等）应该对于扩展开放，对于修改是封闭的**


单一职责原则告诉我们实现类要职责单一；
里氏替换原则告诉我们不要破坏继承体系；
依赖倒置原则告诉我们要面向接口编程；
接口隔离原则告诉我们在设计接口的时候要精简单一；
迪米特法则告诉我们要降低耦合；
而开放封闭原则是总纲领，他告诉我们要对扩展开放，对修改关闭。