---
title: MyBatis
tags:
  - note
  - MyBatis
comments: false
categories:
  - 框架学习
date: 2020-01-10 20:51:07
description:
top:
---

## MyBatis 入门

MyBatis 是基于 Java 并依赖于 Maven 构建 ，在 Maven 的 `pom.xml` 中引入坐标

```xml
<dependency>
  <groupId>org.mybatis</groupId>
  <artifactId>mybatis</artifactId>
  <version>x.x.x</version>
</dependency>
```

## 作用域

**SqlSessionFactoryBuilder**
这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是**方法作用域**（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源可以被释放给更重要的事情。

**SqlSessionFactory**
SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是**应用作用域**。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。

**SqlSession**
每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是**请求或方法作用域**。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。 换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。 这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。 下面的示例就是一个确保 SqlSession 关闭的标准模式：

```java
// jdk7 后的新特性(try-with-resources)
// 放在 try 小括号内的流、连接等任何继承了 java.lang.AutoCloseable / java.io.Closeable 接口的类都可以确保使用完后被关闭
try (SqlSession session = sqlSessionFactory.openSession()) {
  ...
  // 你的应用逻辑代码
}
```

**映射器是一些由你创建的、绑定你映射的语句的接口**，它的最佳的作用域是**方法作用域**，但一般放在 try 的大括号内，随着 session 创建的而存在（映射器接口的实例是从 SqlSession 中获得的）

```java
try (SqlSession session = sqlSessionFactory.openSession()) {
  ...
  // 使用 SqlSession 创建对应 Dao 接口的代理对象 empDao
  EmpDao empDao = session.getMapper(EmpDao.class);
  ...
}
```

## 主配置文件

一般命名为 `SqlMapConfig.xml`

配置树如下

* configuration（配置）
  * properties（属性）
  * settings（设置）
  * typeAliases（类型别名）
  * typeHandlers（类型处理器）
  * objectFactory（对象工厂）
  * plugins（插件）
  * **environments（环境配置）**
    * environment（环境变量）
    * transactionManager（事务管理器）
    * dataSource（数据源）
  * databaseIdProvider（数据库厂商标识）
  * **mappers（映射器）**

```text

0.从 XML 中构建 SqlSessionFactory

1.每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。
SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。
而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。

2.从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。
但是也可以使用任意的输入流（InputStream）实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。
MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易

3.XML 配置文件中包含了对 MyBatis 系统的核心设置
包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）
mappers 元素则是包含一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息

```

## 映射配置文件

动态 SQL
**if**
**choose (when, otherwise)**
**trim (where, set)**
**foreach**

## if

动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分， 解决 DBUtils或其他工具手动拼接 SQL 语句的窘境

## where

where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除

## foreach

动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候

```xml
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  WHERE ID in
  <foreach item="item" index="index" collection="list"
      open="(" separator="," close=")">
        #{item}
  </foreach>
</select>
```

foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。

注意 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值
