---
title: 分布式事务
tags:
  - note
comments: false
categories:
  - 分布式与微服务
date: 2020-04-23 10:23:34
description:
top:
---

随着组织规模不断扩大，业务量不断增长，单机应用和数据库已经不足以支持庞大的业务量和数据量，这个时候需要对应用和数据库进行拆分，就出现了一个应用需要同时访问两个或两个以上的数据库情况。开始我们用分布式事务来保证一致性，也就是我们常说的两阶段提交协议（2PC）。2PC有个致命缺点就是不支持NoSQL，这使得微服务架构不得不摒弃它。

### 传统分布式事务模式

2PC、3PC协议能保证数据的强一致性，但不是分布式系统中一致性保证的最佳实践。原因如下：

1）分布式系统中各个应用的数据大多是自己私有的，应用之间通过API进行访问，这种方式使得应用之间松耦合，彼此之间很容易进行扩展。若通过传统分布式事务，则将不同应用的数据访问捆绑在一起。

2）不同应用使用不同数据库，若有的应用使用NOSQL数据库，这些非关系型数据库不支持2PC。

### 微服务架构中应满足数据最终一致性原则

实现的3种模式

1) 可靠事件模式（事件驱动-异步消息）
2) 补偿模式(saga模型-补偿子事务)
3) TCC（Try、Confirm、Cancel）

### CAP

对于共享数据系统，最多只能同时拥有CAP其中的两个，任意两个都有其适应的场景，真是的业务系统中通常是ACID与CAP的混合体。分布式系统中最重要的是满足业务需求，而不是追求高度抽象，绝对的系统特性。
C表示一致性，也就是所有用户看到的数据是一样的。
A表示可用性，是指总能找到一个可用的数据副本。
P表示分区容错性，能够容忍网络中断等故障。

以前说CAP理论，说对于一个分布式系统，上面3个，只能同时满足2个。但这个其实不准确，P其实一定存在，是你避免不了的。能做的，其实主要是在C和A之间权衡。

比如拿Mysql来说，它的C最强，A次之，P最弱。如果你为了A，给数据做冗余，比如重写轻读，那C就很难保证；为了P，给数据做分库分表，那就做不了事务；

比如Nosql，P最强，可以很好的做数据拆分，但C就不够，做不了事务；

比如微博系统，对C的要求降低，就可以加很多缓存，提高A；数据分片，提高P；

而支付，交易转帐，对C的要求很高，就不能简单的用Cache来提高性能

最终一致性

前面提到，在分布式系统中，因为数据的分拆，服务的分拆，强一致性就很难保证。这个时候，用的最多的就是“最终一致性“。

强一致性，弱一致性，最终一致性，是一致性的几个不同的等级。在传统的关系型数据库中，通过事务来保证强一致性。

但在分布式系统中，通常都会把强一致性折中成最终一致性，从而变相的解决分布式事务问题。最终一致性的实现，通常都需要一个高可靠的消息队列

### BASE

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写，是对 CAP 中 AP 的一个扩展。

基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。

软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。

最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。

BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。

BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。

### XA 规范

事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。
事务协调器要求每个数据库提交数据，或者回滚数据。

XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。
二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现XA分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)

### 柔性事务解决方案架构

#### 2PC

seata

#### 3PC

#### TCC 事务补偿型

TCC（Try-Confirm-Cancel） 事务机制相比于上面介绍的 XA，解决了如下几个缺点：

解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。

在TCC模式下，先保存草稿（Try）再发送（Confirm），撤销的话直接删除草稿（Cancel）就行了

#### 最大努力通知型

实现：业务活动的主动方在完成处理之后向业务活动的被动方发送消息，允许消息丢失。业务活动的被动方根据定时策略，向业务活动的主动方查询，恢复丢失的业务消息。
约束：被动方的处理结果不影响主动方的处理结果。
成本：业务查询与校对系统的建设成本。
使用范围：对业务最终一致性的时间敏感度低。跨企业的业务活动。
特点：业务活动的主动方在完成业务处理之后，向业务活动的被动方发送通知消息。主动方可以设置时间阶梯通知规则，在通知失败后按规则重复通知，知道通知N次后不再通知。主动方提供校对查询接口给被动方按需校对查询，用户恢复丢失的业务消息。


### 基于可靠消息的最终一致性方案

### 幂等性

**幂等操作**：是其任意多次执行所产生的影响均与一次执行的影响相同（不用担心重复执行会对系统造成改变）

**业务场景**：模拟一个用户下单场景，如果用户端因网络问题引发用户重复点击多次，会生成多个订单号，会造成系统业务问题。

**幂等性解决方案**
* 数据库表加唯一索引，防止新增脏数据。比如对订单号进行加唯一索引，防止生成重复订单。
* 分布式锁，利用redis，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁

