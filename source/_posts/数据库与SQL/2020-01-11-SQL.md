---
title: SQL
tags:
  - note
  - SQL
comments: false
categories:
  - 数据库与SQL
date: 2020-01-11 19:51:45
description:
top:
---

{% note info %} 

数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称 DBMS

{% endnote %}


# SQL必知必会

## 主键

表中的任何列都可以作为主键，只要它满足以下条件：

* 任意两行都不具有相同的主键值；

* 每一行都必须具有一个主键值（主键列不允许 NULL 值）；

* 主键列中的值不允许修改或更新；

* 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）

## 字段（field）

基本上与列（column）的意思相同，不过数据库列一般称为列，而术语字段通常与计算字段一起使用。

## SQL

SQL 是一种专门用来与数据库沟通的语言。它专门用来跟数据库沟通的语言。

设计SQL的目的是**提供一种从数据库中读写数据的简单有效方法**

> SQL 语句不区分大小写
> 多条 SQL 语句必须以分号（；）分隔
> 在处理 SQL 语句时，其中所有空格都被忽略

>子句（clause）
>SQL 语句由子句构成，有些子句是必需的，有些则是可选的。一个子
>句通常由一个关键字加上所提供的数据组成。

## 查询数据

* SELECT 

  - 查询单列  `SELECT name FROM students; `

    从students表中查询出一个名为name的列，所需要查询的列名跟在SELECT后面，

  FROM关键字指出从哪个表中查询。

  - 查询多列  `SELECT name， age FROM students；`

    此SQL指定了两个列名，用逗号分隔。

  - 查询所有列 `SELECT * FROM students；`

    给定一个通配符（*），则返回表中所有列。

  - 查询非重复值  `SELECT DISTINCT age FROM students；`

    使用`DISTINCT`关键字排除年龄相同的学生，它必须放在列名的前面。

  - 限制查询  `SELECT name FROM students LIMIT 2 OFFSET 3;`

    使用`LIMIT`关键字限制查询的条数为两条，`OFFSET`后跟行号（此行不参与查询）

    简化版  `SELECT name FROM students LIMIT 3，2;`

    此时，逗号之前的值对应省略的 OFFSET ，逗号之后的值对应 LIMIT

  - 聚合函数
    * count(列名)，统计记录条数，若列中可能有值为null，可以使用 ifnull(字段名，默认值) 例：select count(ifnull(total，0)) from user 将 null 的记录的赋值为 0
    * max(列名)，统计列中最大值
    * min(列名)，统计列中最小值
    * sum(列名)，统计列中数据和
    * avg(列名)，求列内平均值

  — 分组查询(重点)
  语法：
  - 场景 1 ：根据性别分组， 并统计每组学生的总人数
      select sex count(*) from students group by sex;

  - 场景 2 ：根据性别分组， 统计组内学生的总人数 > 3 的(分组后筛选)
      select sex，count(id) sum from user group by sex having sum > 3;

  总结：
  * 根据某一列进行分组， 将分组字段结果中相同内容作为一组; 有几组 返回的记录就有几条
  * 单独分组 没有意义， 返回每一组的第一条记录
  * 分组的目的一般为了做统计使用， 所以经常和聚合函数一起使用
  * 在分组里面， 如果 select 后面的列没有出现在 group by 后面 展示这个组的这个列的第一个数据
  * where 和 having 的区别

| 子名       | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| where 子句 | 1) 对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，即先过滤再分组。2) where后面不可以使用聚合函数 |
| having字句 | 1) having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，即先分组再过滤。2) having后面可以使用聚合函数 |

- 分页查询

LIMIT 跳过的数据条数，查询记录条数;                 


## 排序数据

1.单列排序

  ​`SELECT name FROM students ORDER BY age;`

  从students 表中查询名为 name 的列，并按 age 大小排序。

  **ORDER BY 应是SELECT 语句中的最后一条子句。**

> 使用ORDER BY 子句进行升序排序，子句后跟排序的参照列，通常为查询列，也可不为查询的列（查询字段）。
 


2.多列排序

  ` SELECT name，sex FROM students ORDER BY age，number;`

  在多个列进行排序时，仅在有相同 age 行时，才会按 number 进行再次排序，否则不会按 number 进行排序。

  ​

 按照查询列的相对位置排序

  ` SELECT name，age FROM students ORDER BY 2，1;`

> 当不采用查询字段进行排序时，无法使用此技术。



4.指定排序方向

  `SELECT name FROM students ORDER BY age DESC;`

  在 ORDER BY 子句后 加上 `DESC` 关键字，表明此排序为降序排序。升序是默认的，关键字为`ASC` ，无需手动指定。
> 在多个列上降序排序
> 如果想在多个列上进行降序排序，必须对每一列指定 DESC 关键字。

## 过滤数据

* WHERE 子句 **应在 表名 （FROM 子句）后给出。**

  `SELECT NAME FROM students WHERE age=8 ;`

  此语句查询出age = 8 的 name 字段。

  `SELECT NAME，sex FROM students WHERE sex<>'男' ;`

  此语句查询出sex不等于男的 name ， sex 字段。

>何时使用引号?
>
> 如果将值与字符串类型的列进行比较，就需要限定引号。用来与数值列进行比较的值则不用。


## 高级过滤

* 组合WHERE 子句（使用圆括号明确分组操作符）

  * AND：用来查询**满足所有给定条件**的行。
  * OR：用来查询**任一给定条件**的行。

* IN 操作符

  IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配

  IN 取一组由逗号分隔、括在圆括号中的合法值

  优点

  * 更清楚直观
  * 求值顺序更容易管理
  * 比一组OR 操作符执行更块
  * 可以包含其他 SELECT 语句，可以动态建立WHERE 子句

* NOT 操作符

  NOT 操作符用来否定其后面跟的任何条件，从而排除此条件

  常用于跟 IN 操作符搭配使用过滤

  ```sql
  -- 用于查询排除湖南、杭州的行
  SELECT
  	NAME，age，address
  FROM
  	students
  WHERE
  	NOT address IN('湖南'，'杭州');
  ```


## 使用通配符过滤

特点：过滤条件未知

通配符搜索只能用于文本字段（字符串），非文本数据类型字段不能使用通配符搜索。

**LIKE 操作符**

% ：表示任何字符出现的任意次数，单独出现的话将会匹配所有（不包括NULL）

```sql
-- 1.用于查询出所有以"马"开头的行
SELECT
  NAME，age，address
FROM
  students
WHERE
  NAME LIKE "马%"; 
  
-- 2.用于查询出所有包含"马"的行	
SELECT
  NAME，age，address
FROM
  students
WHERE
  NAME LIKE "%马%"; 
```

_ ：以单个下划线 _ 表示匹配一个字符

```sql
-- 用于查询出名称为3个字且中第二个字为"马"
SELECT
  NAME，age，address
FROM
  students
WHERE
  NAME LIKE "_马_"; 
```

~~[ ] ：用来指定一个字符集，必须指定指定位置（通配符的位置）的一个字符~~ （MySQL 中不支持）

## 子查询

在 SELECT 语句中，子查询总是从内向外处理。在处理上面的 SELECT 语句时，DBMS 实际上执行了两个操作。

# MySQL

## MySQL架构与历史

### MySQL的schema的定义

**schema 就是数据库对象的集合，所谓的数据库对象也就是常说的表，索引，视图，存储过程等**

> MySQL官方文档指出，从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。但是从物理层面上来说，模式与数据库是同义的。你可以在MySQL的SQL语法中用关键字 SCHEMA 替代 DATABASE ，例如使用`CREATE SCHEMA`来代替`CREATE DATABASE`。
>
> ​	在MySQL中基本认为schema和数据库相同，也就是说schema的名称和数据库的实例的名称相同，一个数据库有一个schema	

### 逻辑架构

- 服务器层的服务
- 查询执行引擎
- 存储引擎

### 并发控制

##### 读写锁

- 读锁/S锁/共享锁

  读锁是共享的，或者说是互不阻塞。多个客户可以同时读取同一数据，而互不干扰。


- 写锁/X锁/排他锁

  写锁是排他的，一个写锁会阻塞（排斥）其他的写锁和读锁，以确保同一时间内只有一个用户才能执行写入。

##### 锁粒度

- 表锁（table look）：开销最小的策略，是MySQL中最基本的锁策略。
- 行级锁（row look）：开销最大的策略，可以最大程度的支持并发处理。

### 事务

概念：一组原子性的SQL查询或一个独立的工作单元。

#### ACID特性

- 原子性（atomicity）：事务必须被视为最小不可分割工作单元，事务中所有操作要么全部成功，要么全部失败回滚。
- 一致性（consistency）：数据库总是从一个一致性的状态转为另一个一致性的状态。
- 隔离性（isolation）：通常来说并发的事务之间不会互相影响，一个事务所作的修改在最终提交之前，对其他事务是不可见的。
- 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库。

#### 隔离级别

- 读未提交（Read Uncommitted）：事务中的修改即使未提交，对其他事务同样可见

- 读已提交（Read committed）：事务从开始到提交之前，对其他事务不可见

- 可重复读（Repeatable Read）:保证了在同一个事务中多次读取同样的记录结果是一致的（MySQL默认隔离级别）

- 可串行化(Serializable）：通过强制事务串行执行，在读取的每一行数据都加锁。


|事务隔离级别|	脏读|	不可重复读|	幻读|
|----|---|---|---|
|读未提交|是|是|是|
|读已提交|否|是|是|
|可重复读|否|否|是|
|可串行化|否|否|否|


{%note info%}
幻读：指当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新记录，当前事务再次读取该范围记录时，会产生幻行。
{%endnote%}

#### 死锁

什么是死锁？

死锁指两个或者多个事务在同一资源上相互占用，并请求获取对方的排他锁，从而导致的恶性循环的现象。

死锁的产生：
* 当多个事务试图以不同顺序锁定资源时，就会产生死锁。
* 当多个事务同时锁定同一个资源时，也会产生死锁。

死锁的解决：部分或者完全回滚其中一个事务，才能打破死锁。

#### MySQL中的事务

非事务型的存储引擎：MyISAM、内存表。没有commit和rollback的概念，默认一直处于自动提交（不能回滚）

MySQL提供两种事务型的存储引擎：`InnoDB`和 `NDB Cluster`

- 使用START TRANSACTION开启事务
- 使用COMMIT提交事务
- 使用ROLLBACK回滚事务

**MySQL默认使用自动提交事务（AutoCommit），可以通过修改autocommit的value**

**0/OFF表示禁用，1/ON表示开启。**

### 多版本并发控制 MVCC

MVCC是行级锁的变种，避免了很多加锁操作，开销更低。

不同存储引擎的MVCC实现不同，典型的有乐观（optimistic）并发控制和悲观（pessimistic）并发控制。

**1.MVCC下InnoDB行为：**

- 通过在每一行后面保存两个隐藏列（一列保存创建时间，一列保存销毁时间，这里时间指的是系统版本号）。
- 每开始一个新事务，系统版本号递增，事务开始时的系统版本号作为此事务的版本号，用来和查询到的每行记录的版本号进行比较。

**2.在Repeatable Readb隔离级别下，具体的MVCC操作：**

- Select：

  InnoDB将会根据以下两个条件检查每行记录：

  - 查找版本号小于或等于当前事务的版本号（确保事务读取的行，应在事务开始前已存在或事务自身插入或者修改的）
  - 行的删除版本号要么未定义，要么大于当前事务的版本号（确保事务读取的行，在事务开始前已被删除）
    **两个条件是必要条件，只要满足才能返回查询结果。**

- Insert：InnoDB为新插入的每一行保存当前系统版本号作为行创建版本号

- Delete：InnoDB为新删除的每一行保存当前系统版本号作为行删除标识。

- Update：InnoDB为新插入每一行新记录，保存当前系统版本号作为行创建版本号，同时保存当前系统版本号到原来的行作为行删除标识。

MVCC只工作在Repeatable Read和Read committed隔离级别。

因为Read Uncommitted读取的行总是最新的

而Serializable则会对读取的每行进行加锁

### MySQL的存储引擎

#### InnoDB引擎概览

InnoDB 引擎是MySQL 5.5 及以后的版本**默认事务引擎** ，2008年发布的InnoDB plugin，不支持

全文索引（可使用sphinx插件），适用于MySQL5.1版本。**MySQL中规定自增列必须为主键**。

- InnoDB的数据存储在表空间（tablespace）或多表空间中

  如果使用多表空间，那么每个表都有一个表空间文件用于存储每个表的数据和索引，文件名

  以表名开头，以.ibd为扩展名。

- InnoDB采用MVCC来支持高并发，并且实现了四个标准隔离级别。默认级别为可重复读

  （Repeatable Read），并通过**间隙锁**防止幻读出现。使得InnoDB不仅仅锁定查询涉及行，

  还对索引中间的间隙进行锁定，防止幻影行的插入。

- InnoDB表是基于**聚簇索引建立**，存储格式是平台独立的

- InnoDB内部的优化：可预测性预读、自适应哈希索引、插入缓冲区

- InnoDB的行为非常复杂，可参考官方手册的“InnoDB事务模型和锁“

- InnoDB可以通过一些机制和工具支持真正的热备份

- InnoDB创建的是索引组织表

>mysql中每个表都有一个聚簇索引，除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。
>
>以InnoDB来说，每个InnoDB表具有一个特殊的索引称为聚集索引。
>
>* 如果表上定义有主键，该主键索引是聚集索引。
>* 如果不定义为表的主键时，MySQL取第一个唯一索引（unique）而且只含非空（NOT NULL）作为主键，InnoDB使用它作为聚集索引。
>* 如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。



#### MyISAM引擎

MySQL 5.1 及之前版本的默认引擎。设计简单，只支持表锁，不支持事务和行级锁。

MyISAM  创建的是堆表。每张MyISAM 表被存放在三个文件 。`.frm`文件件存放表结构。 数据文件是`.MYD` (MYData) ， 索引文件是 `.MYI `(MYIndex) 。

#### MEMORY存储引擎

MEMORY存储引擎使用存储在内存中的内容来创建表，所有数据也放在内存中。

每个基于 MEMORY 存储引擎的表实际对应一个磁盘文件。

该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。

而其数据文件，都是存储在内存中。这样有利于对数据的快速的处理，提高整个表的处理效率。

#### 第三方存储引擎

- OLTP类引擎
- 面向列的存储引擎 ：Info bright
- 社区存储引擎

尽量避免使用混合引擎存储。若需要则考虑以下几点因素

- 事务
- 备份
- 崩溃恢复
- 特性

#### 转换表的使用引擎

- ALTER TABLE

- 导入与导出

- 创建与查询（高效且安全）

## MySQL基准测试

基准测试的两种策略

- 集成式：针对整个系统的整体测试

  测试工具

  - ab
  - http_load
  - JMeter

- 单组件式：针对MySQL的单独测试

  测试工具

  - MySQL slap
  - MySQL Benchmark Suite
  - Super Smark
  - Database Test Suite
  - Percona's TPCC_MySQL Tool
  - sysbench

基准测试的测试指标

- 吞吐量：单位时间内事务处理数
- 响应时间或延迟：测试任务所需的整体时间
- 并发性：正在工作中的并发操作或是同时工作的线程数或者连接数
- 可扩展性

MySQL的内置 `BENCHMARK()`，用于测试SQL执行速度的测量。

**性能指的是响应时间，性能优化工作需要基于高质量、全方位及完全的响应时间测量。**

完整的测量会产生大量需要分析的数据，需用到剖析器，剖析报告是汇总信息，掩盖和丢弃大量细节，所以不要完全依赖剖析报告。


## Schema与数据类型优化

### 选择优化的数据类型

类型选择简单原则

- 更小的：例如只需要存 0~200，则选择 tinyint unsigned
- 更简单的：例如存储日期使用内建类型 date、time、datetime，而不是字符串varchar
- 避免 null

**整数类型** whole number

可选UNSIGNED属性，表示不允许负值，大致可使正数上限提升一倍。

- TINYINT ：8bit
- SMALLINT：16bit
- MEDIUMINT：24bit
- INT：32bit
- BIGINT：64bit

**实数类型** real number

- FLOAT：浮点数类型
- DOUBLE：浮点数类型
- DECIMAL：定点数类型

**字符串类型**

- VARCHAR：可变长
- CHAR：定长
- TEXT 
- ENUM代替

**日期和时间类型**

- YEAR
- TIME
- DATE
- DATETIME
- TIMESTAMP

**位数据类型**

- BIT：最大长度64bit
- SET：常用于保存大量true/false值
- BLOB

**选择标识符**

- 整数类型：通常是标识列的最好选择，速度快且可自增长
- ENUM和SET类型：避免使用作为标识列
- 字符串类型：避免使用作为标识列

### 范式和反范式

在范式化的数据库中，每个事实数据会出现并且只会出现一次

在反范式化的数据库中，信息是冗余的，可能会存储在多个位置


**范式的优点和缺点**

优点：

- 更新操作较快
- 重复数据较少
- 生成的表较小

缺点：范式化设计的schema通常需要关联

**反范式的优点和缺点**

优点：

- 反范式化设计的schema因为所有数据在一张表中，避免了关联


- 当全表扫描时，避免了随机IO

缺点：更新操作慢、重复数据较多

**混合范式化和反范式化**



### 缓存表和汇总表

缓存表：表示存储那些可以比较简单地从schema其他表获取数据的表

汇总表：表示保存的是使用GROUP BY语句聚合数据的表

**物化视图**

MySQL并不支持原生物化视图，可以使用Flex views实现

**计数器表**

常用于缓存一个用户的好友数量、文件下载次数等。

### 加快ALTER TABLE操作速度

- 只修改 .frm 文件
- 快速创建MyISAM索引

### 设计原则

- 尽量避免会导致极其复杂查询的schema设计、有很多列的表设计
- 使用小而简单的合适数据类型，除非需要，否则避免使用NULL
- 尽量使用相同的数据类型存储相似或相关的值
- 注意可变长字符串、尽量使用整型定义标识列
- 避免使用MySQL已遗弃的特性，例如指定浮点的精度、整数的显示宽度
- 小心使用ENUM和SET，避免使用BIT

## 创建高性能的索引

索引（MySQL中也称为“键”）：存储引擎用于快速找到记录的一种数据结构。

索引分类：

> 1．普通索引
> 2．惟一性索引
> 3．全文索引
> 4．单列索引
> 5．多列索引
> 6．空间索引

### 索引基础

**索引类型**

- B-Tree索引：通常意味着所有值按顺序存储，并且每个叶子页到跟的距离相同。从索引的根节点开始进行搜

- 索，根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。**B-Tree对索引列是有顺序**

  **组织存储的，利于范围查找数据**

  - MyISAM相关：使用前缀压缩技术使索引更小，通过数据的物理位置引用被索引的行
  - InnoDB相关 ：按照原数据格式进行存储，根据主键引用被索引的行 
  ​
  **B-Tree的查询类型** ：适用于全键值、键值范围或键前缀查找（只适用与根据最左前缀的查找）。

  - 全值匹配
  - 匹配最左前缀
  - 匹配列前缀
  - 匹配范围值
  - 精确匹配某一列并范围匹配另外一列
  - 只访问索引的查询

    B-Tree的查询限制 ：

  + 若不是按照索引的最左列开始，则无法使用
  + 不能跳过索引中的列
  + 若查询中有某个列的范围查询，则其右边所有的列都无法使用索引优化查找

  ​

- **哈希索引**：基于**哈希表**实现，只有精确匹配索引所有列的查询才有效（只有Memory引擎支

  持并且支持非唯一哈希索引），它可以将很长的索引简化。

  哈希索引的限制 ：

  - 只包含哈希值和行指针，而不存储字段值
  - 不是按照索引值顺序存储，无法用于排序
  - 不支持部分索引列匹配查找
  - 只支持等值比较查询
  - 哈希冲突很多的时候对查询速度的影响较大，维护代价也会增高

- 空间数据索引 R-Tree

- 全文索引：查找的是文本中的关键词，而不是直接比较索引值

- 其他索引类别：TokuDB使用的分形树索引（fractal tree index）

### 索引的优点

- 大大减少了服务器需扫描的数据量
- 索引可帮助服务器避免排序和临时表
- 索引可将随机I/O变为顺序I/O

> 索引并非为最佳解决方案，只有当索引帮助存储引擎快速查找到记录时带来的好处大于带来的其他额外开销时，索引才是有效的。对于非常小的表，大部分情况下使用简单的全表扫描更高效，而对于中大型的表，则使用索引。

### 高性能的索引策略

**独立的列** ：指索引列不能是表达式的一部分，也不能是函数的参数，必须为独立的。

**索引选择性** ：不重复的索引值（基数cardinality）和数据表的行数（*#T*）的比值，唯一索引的选择性是 1，性能最好。

**前缀索引** ：用索引开始的部分字符进行索引，会降低索引的选择性。

**多列索引** ：MySQL 5.0及更新版本后引入 `索引合并` 策略：

> - OR 条件的联合  union
> - AND 条件的相交 intersection
> - 组合前两者的联合及相交

**聚簇索引** ：一种数据存储方式

> InnoDB 实现：在同一个结构保存B-Tree 的索引和数据行。
>
> 表中有聚簇索引时，数据行存放在索引的叶子页中，一个表只能有一个聚簇索引

优点：

* 可以将相关数据存储到一起
* 数据访问快
* 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

缺点：

* 聚簇索引提高I/O 密集型应用的性能，但对数据放在内存中的时候，优势不大
* 插入速度严重依赖于插入顺序，更新聚簇索引列的代价很高
* 插入新行或主键更新需要移动行时，可能面临 “页分裂” 问题

**覆盖索引** ：一个索引包含（覆盖）所有需要查询的字段的值

**前缀压缩索引** ：MyISAM


待办。。。
